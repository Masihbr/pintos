تمرین گروهی ۳ - مستند طراحی
======================

گروه
-----

>>‫نام و آدرس پست الکترونیکی اعضای گروه را در این قسمت بنویسید.


مسیح بیگی ریزی <masihbr@gmail.com>

درین ستوده <dorrinsotoudeh123@gmail.com>

علی مورکیان <moroukianali@gmail.com>

مقدمات
----------

>>‫ ‫‫اگر نکات اضافه‌ای در مورد تمرین یا برای دستیاران آموزشی دارید در این قسمت  ‫بنویسید.

>>‫ لطفا در این قسمت تمامی منابعی (غیر از مستندات Pintos، اسلاید‌ها و دیگر منابع‫ ‫درس) را که برای تمرین از آن‌ها استفاده کرده‌اید در این قسمت بنویسید.

بافر کش
============

داده‌ساختار‌ها و توابع
---------------------

>>‫ در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را‫ بنویسید و دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

```c
// inode.c
...
#include "threads/synch.h"

/* Identifies an inode. */
#define INODE_MAGIC 0x494e4f44

typedef struct cache_block
{    
  struct list_elem elem;              /* Element in inode list. */
  block_sector_t sector;              /* Sector number (or NULL when invalid) of disk location. */
  bool dirty;                         /* cache block is dirty and should be written back on remove from lru_cache_list. */
  char data[BLOCK_SECTOR_SIZE];       /* cached data with size of each block sector. */
  struct lock lock;                   /* lock for Synchronization (multiple threads accessing cache_block). */
} cache_block_t;

cache_block_t cache_blocks[64];       /* cache blocks with size of 64. */
struct list lru_cache_list;           /* cache list with lru replacement policy.*/
struct lock lru_cache_list_lock;      /* lock for Synchornization (multiple threads accessing lru_cache_list).*/

static void read_block_cache (block_sector_t sector, void *buffer_, off_t size,
                        off_t offset);
static void write_block_cache (block_sector_t sector, void *buffer_, off_t size,
                        off_t offset);

...
```

 از  داده ساختار `cache_block_t` برای cache کردن هر سکتور از دیسک استفاده می‌شود. آرایه `cache_blocks` حاوی ۶۴ آیتم از این داده ساختار خواهد بود و برای نگهداری و تعریف هر `cache_block_t` در حافظه مورد استفاده قرار می‌گیرد و لیست `lru_cache_list` وظیفه اصلی نگهداری، سرچ، الگوریتم جایگزینی و دیگر مسائل مربوط به caching را هندل می‌کند.

الگوریتم‌ها
------------

>>‫ توضیح دهید که الگوریتم مورد استفاده‌ی شما به چه صورت یک بلاک را برای جایگزین ‫ شدن انتخاب می‌کند؟

 از الگوریتم LRU استفاده خواهیم کرد بدین صورت که اگر یک سکتور در لیست (`lru_cache_list`) ما یافت شود آنرا از لیست حذف کرده و در ابتدای لیست قرار می‌دهیم و اگر پیدا نشد با استفاده از `block_read` مانند حالت بدون cache ابتدا دیسک را خوانده و سپس خانه اخر `lru_cache_list` را حذف کرده و اطلاعات خوانده شده را در آن قرار می‌دهیم 
و به سر لیست می‌چسبانیم.
>>‫ روش پیاده‌سازی `read-ahead` را توضیح دهید.

یک استراتژی ساده برای پیاده سازی `read-ahead` این است که هنگام خواندن حافظه پس از miss شدن cache سکتور بعدی نیز خوانده شود و در cache قرار بگیرد در این صورت دو خانه جدید ابتدا لیست اضافه شده و دو خانه اخر حذف می‌شود.

برای انجام `read-ahead` بهتر به استراتژی پیچیده تری نیاز است به طور مثال نگه داشتن یکسری metadata از دسترسی به فایل‌ها و پیشگویی استفاده از هر block از فایل با استفاده از الگوریتم‌های پیشگو (مانند Markov Chain models, Linear Regression models, ...) و cache کردن بلاک‌های پیشبینی شده در پس زمینه.

همگام سازی
-------------

>>‫ هنگامی که یک پردازه به طور مستمر در حال خواندن یا نوشتن داده در یک بلاک بافرکش‫ می‌باشد به چه صورت از دخالت سایر پردازه‌ها جلوگیری میشود؟

این lock موجود در `cache_block_t` هنگام خواندن و نوشتن acquire شده و جلوی دسترسی همزمان چند ریسه متفاوت را می‌گیرد.

>>‫ در حین خارج شدن یک بلوک از حافظه‌ی نهان، چگونه از پروسه‌های دیگر جلوگیری می‌شود تا‫ به این بلاک دسترسی پیدا نکنند؟

برای ایجاد هرگونه تغییر در `lru_cache_list` لازم است، لاک `lru_cache_list_lock` را بگیریم و این لاک از دسترسزی همزمان چند ریسه متفاوت و ایجاد تغییر همزمان جلوگیری می‌کند.

منطق طراحی
-----------------

>>‫ یک سناریو را توضیح دهید که از بافر کش، `read-ahead` و یا از `write-behind` استفاده کند.

سناریو برای cache buffer جلوتر توضیح داده شده.

سناریویی که `read-ahead` استفاده کند: اگر فایل بزرگی به صورت ترتیبی خوانده شود (video streaming, DB, Gaming) و یا بخواهیم فایل بزرگی را به صورت ترتیبی بنویسیم استفاده از این فیچر به ما کمک می‌کند.

سناریویی که `write-behind` استفاده کند: نوشتن داده به صورت asynch و priodic هنگامی که صف I/O خالی است می‌تواند در موارد قطعی برق و کرش‌های ناگهانی و اشکالات سخت افزاری کمک کننده باشد و همچنین ترافیک I/O  را به طور کلی کاهش دهد.

فایل‌های قابل گسترش
=====================

داده‌ساختار‌ها و توابع
---------------------

>>‫ در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری‫ یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را بنویسید و‫ دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

/filesys/inode.c

``` diff
+ #define DIRECT_BLOCKS_COUNT 123  // (512 - 5 * 4) / 4 = 123; sizeof(inode_disk) should be 512

struct inode_disk
  {
-   block_sector_t start;               /* First data sector. */
    off_t length;                       /* File size in bytes. */
    unsigned magic;                     /* Magic number. */
-   uint32_t unused[125];               /* Not used. */

    /* Unix FFS (Fast File System) */
+   block_sector_t direct_blocks[DIRECT_BLOCKS_COUNT];  /* Direct pointers */
+   block_sector_t indirect_blocks;                     /* Indirect pointers */
+   block_sector_t doubly_indirect_blocks;              /* Doubly-indirect pointers */

+   int type_is_dir;                    /* 1.3. Subdirectories */
  };

struct inode
  {
    struct list_elem elem;              /* Element in inode list. */
    block_sector_t sector;              /* Sector number of disk location. */
    int open_cnt;                       /* Number of openers. */
    bool removed;                       /* True if deleted, false otherwise. */
    int deny_write_cnt;                 /* 0: writes ok, >0: deny writes. */
    struct inode_disk data;             /* Inode content. */
+   struct lock ilock;                  /* Inode lock. */
  };

```

فیلد start با پوینترهای مستقیم و غیر مستقیم جایگزین شده است.

همچنین توابع جدیدی برای انجام تغییرات(حذف/ایجاد) روی inode اضافه می‌شود.

>>‫ بیشترین سایز فایل پشتیبانی شده توسط ساختار inode شما چقدر است؟

(123 + 128 + 128 * 128) * 512 = 8517120 Bytes = 8.51712 MB

همگام سازی
----------

>>‫ توضیح دهید که اگر دو پردازه بخواهند یک فایل را به طور همزمان گسترش دهند، کد شما چگونه از‫ حالت مسابقه جلوگیری می‌کند.

از آنجا که هر پردازه برای استفاده از استراکت inode باید قفل ilock را بگیرد، در نتیجه مسابقه پیش نمی‌آید.

>>‫ فرض کنید دو پردازه‌ی A و B فایل F را باز کرده‌اند و هر دو به end-of-file اشاره کرده‌اند.‫ اگر  همزمان A از F بخواند و B روی آن بنویسد، ممکن است که A تمام، بخشی یا هیچ چیز از‫ اطلاعات نوشته شده توسط B را بخواند. همچنین A نمی‌تواند چیزی جز اطلاعات نوشته شده توسط B را‫ بخواند. مثلا اگر B تماما ۱ بنویسد، A نیز باید تماما ۱ بخواند. توضیح دهید کد شما چگونه از‫ این حالت مسابقه جلوگیری می‌کند.

با توجه به تعریف قفل ilock امکان وقوع چنین اتفاقی وجود ندارد و پردازه‌های A و ‌B نمی‌توانند همزمان از یک inode استفاده کنند.

>>‫ توضیح دهید همگام سازی شما چگونه "عدالت" را برقرار می‌کند. فایل سیستمی "عادل" است که‫ خواننده‌های اطلاعات به صورت ناسازگار نویسنده‌های اطلاعات را مسدود نکنند و برعکس. بدین ترتیب‫ اگر تعدادی بسیار زیاد پردازه‌هایی که از یک فایل می‌خوانند نمی‌توانند تا ابد مانع نوشده شدن‫ اطلاعات توسط یک پردازه‌ی دیگر شوند و برعکس.

با توجه به تعریف قفل و تصادفی بودن دریافت قفل توسط پردازه‌ها، عدالت در فایل سیستم برقرار می‌شود.

منطق طراحی
----------

>>‫ آیا ساختار `inode` شما از طبقه‌بندی چند سطحه پشتیبانی می‌کند؟ اگر بله، دلیل خود را برای‫ انتخاب این ترکیب خاص از بلوک‌های مستقیم، غیر مستقیم و غیر مستقیم دوطرفه توضیح دهید.‌‫ اگر خیر، دلیل خود برای انتخاب ساختاری غیر از طبقه‌بندی چند سطحه و مزایا و معایب ساختار‫ مورد استفاده خود نسبت به طبقه‌بندی چند سطحه را توضیح دهید.

بله. این روش پیاده‌سازی باعث کاهش fragmentation و افزایش سرعت دسترسی به دیسک می‌شود. با توجه به اینکه 123 پوینتر مستقیم داریم دستیابی به فایل‌های کوچک‌تر سریع‌تر می‌شود.

زیرمسیرها
============

داده‌ساختار‌ها و توابع
---------------------

>>‫ در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری‫ یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را بنویسید و‫ دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

```c
// pintos/src/filesys/directory.c
struct dir
  {
    ...
    struct lock lock;       /* Lock for dir modification. */
    int cwd_use_count;      /* The number of thread using this dir or its children. Init at 0. */
  };
```
```c
// pintos/src/threads/thread.h
struct thread
  {
    ...
    struct dir cwd;         /* Current Working Directory. */
    ...
  };
```
```c
struct inode
  {
    int type_is_dir;
  };
```

الگوریتم‌ها
-----------

>>‫ کد خود را برای طی کردن یک مسیر گرفته‌شده از کاربر را توضیح دهید.‫ آیا عبور از مسیرهای absolute و relative تفاوتی دارد؟

ابتدا نام فایل/پوشه را با صرف‌نظر از تکرار "/" بر حسب "/" جدا میکنیم و از ابتدا بصورت زیر مسیر را می‌سازیم:
- اگر نام مسیر با / شروع نشده باشد مسیر relative است و باید مقدار `current_thread ()->cwd` را در ابتدای آن قرار دهیم. 
- اگر در ابتدای مسیر . باشد، باید در ابتدای مسیر مقدار `current_thread ()->cwd` را قرار دهیم.
- اگر در root بودیم .. تاثیری ندارد.
- اگر در root نبودیم هر بار .. را دیدیم آخرین پوشه موجود در مسیر را حذف میکنیم.

همگام سازی
-------------

>>‫ چگونه از رخ دادن race-condition در مورد دایرکتوری ها پیشگیری می‌کنید؟‫ برای مثال اگر دو درخواست موازی برای حذف یک فایل وجود داشته باشد و ‫ تنها یکی از آنها باید موفق شود یا مثلاً دو ریسه موازی بخواهند فایلی‫ یک اسم در یک مسیر ایجاد کنند و مانند آن.‫ آیا پیاده سازی شما اجازه می‌دهد مسیری که CWD یک ریسه شده یا پردازه‌ای‫ از آن استفاده می‌کند حذف شود؟ اگر بله، عملیات فایل سیستم بعدی روی آن‫ دایرکتوری چه نتیجه‌ای می‌دهند؟ اگر نه، چطور جلوی آن را می‌گیرید؟

برای کلیه عملیات‌هایی که ساختار درخت دایرکتوری را تغییر میدهند، از lockای که در struct dir اضافه کردیم استفاده میکنیم.

برای حالتی که یک مسیری‌ که cwd ریسه(ها)ی دیگر است ریسه‌ی دیگری میخواهد آنرا حذف کند، میتوانیم تنها مقدار `cwd_use_count` آن دایرکتوری را بررسی کنیم و اگر صفر نبود منتظر صفر شدن آن بمانیم و سپس دایرکتوری را حذف کنیم. این متغیر تعداد ریسه‌هایی را نشان میدهد که cwd آنها دایرکتوری مذکور باشد. هرگاه که chdir انجام میدهیم هم باید مقدار این متغیر را برای دایرکتوری قبلی کاهش و برای دایرکتوری جدید افزایش دهیم. عملیات کاهش هنگام خروج ریسه نیز انجام میشود.

منطق طراحی
-----------------

>>‫ توضیح دهید چرا تصمیم گرفتید CWD یک پردازه را به شکلی که طراحی کرده‌اید‫ پیاده‌سازی کنید؟

علت انتخاب این روش سادگی در فهم و پیاده‌سازی آن است.
علاوه بر این به آزادسازی working directory قبلی نیز توجه شده است و از حذف و یا تغییر نام working directory یک ریسه توسط ریسه دیگر جلوگیری میکند.

### سوالات نظرسنجی

پاسخ به این سوالات دلخواه است، اما به ما برای بهبود این درس در ادامه کمک خواهد کرد.

نظرات خود را آزادانه به ما بگوئید—این سوالات فقط برای سنجش افکار شماست.

ممکن است شما بخواهید ارزیابی خود از درس را به صورت ناشناس و در انتهای ترم بیان کنید.

>>‫ به نظر شما، این تمرین گروهی، یا هر کدام از سه وظیفه آن، از نظر دشواری در چه سطحی بود؟ خیلی سخت یا خیلی آسان؟

>> چه مدت زمانی را صرف انجام این تمرین کردید؟ نسبتا زیاد یا خیلی کم؟

>>‫ آیا بعد از کار بر روی یک بخش خاص از این تمرین (هر بخشی)، این احساس در شما به وجود آمد که اکنون یک دید بهتر نسبت به برخی جنبه‌های سیستم عامل دارید؟

>>‫ آیا نکته یا راهنمایی خاصی وجود دارد که بهتر است ما آنها را به توضیحات این تمرین اضافه کنیم تا به دانشجویان ترم های آتی در حل مسائل کمک کند؟

>> متقابلا، آیا راهنمایی نادرستی که منجر به گمراهی شما شود وجود داشته است؟

>>‫ آیا پیشنهادی در مورد دستیاران آموزشی درس، برای همکاری موثرتر با دانشجویان دارید؟

این پیشنهادات میتوانند هم برای تمرین‌های گروهی بعدی همین ترم و هم برای ترم‌های آینده باشد.

>>‫ آیا حرف دیگری دارید؟
